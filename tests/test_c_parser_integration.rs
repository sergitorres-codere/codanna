//! Tests for C Parser Implementation\n//!\n//! Validates core C parsing functionality:\n//! - Symbol extraction (functions, structs, enums)\n//! - Function call tracking\n//! - Import/include statement parsing\n//! - Variable and macro definition tracking\n//! - Variable usage tracking\n\nuse codanna::parsing::{LanguageParser, CParser};\n\n#[test]\nfn test_c_parser_symbol_extraction() {\n    println!(\"\\n=== C Parser Symbol Extraction Test ===\\n\");\n\n    let code = r#\"\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 100\n\nint global_var = 42;\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint subtract(int a, int b) {\n    return a - b;\n}\n\nstruct Point {\n    int x;\n    int y;\n};\n\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n};\n\ntypedef struct {\n    int width;\n    int height;\n} Rectangle;\n\nint main() {\n    int result = add(5, 3);\n    return 0;\n}\n\"#;\n\n    let mut parser = CParser::new().expect(\"Failed to create C parser\");\n    let symbols = parser.parse(code, codanna::FileId::new(1).unwrap(), &mut codanna::types::SymbolCounter::new());\n\n    println!(\"Found {} symbols:\", symbols.len());\n    for symbol in &symbols {\n        println!(\"  {:?}: {} at line {}\", symbol.kind, symbol.name, symbol.range.start_line);\n    }\n\n    // Verify expected symbols\n    assert!(\n        symbols.iter().any(|s| s.name == \"add\".into() && matches!(s.kind, codanna::SymbolKind::Function)),\n        \"Should find add function\"\n    );\n\n    assert!(\n        symbols.iter().any(|s| s.name == \"subtract\".into() && matches!(s.kind, codanna::SymbolKind::Function)),\n        \"Should find subtract function\"\n    );\n\n    assert!(\n        symbols.iter().any(|s| s.name == \"Point\".into() && matches!(s.kind, codanna::SymbolKind::Struct)),\n        \"Should find Point struct\"\n    );\n\n    assert!(\n        symbols.iter().any(|s| s.name == \"Color\".into() && matches!(s.kind, codanna::SymbolKind::Enum)),\n        \"Should find Color enum\"\n    );\n\n    assert!(\n        symbols.iter().any(|s| s.name == \"main\".into() && matches!(s.kind, codanna::SymbolKind::Function)),\n        \"Should find main function\"\n    );\n\n    println!(\"✓ All expected symbols found\");\n}\n\n#[test]\nfn test_c_parser_find_calls() {\n    println!(\"\\n=== C Parser find_calls() Test ===\\n\");\n\n    let code = r#\"\nint helper() {\n    return 42;\n}\n\nint process() {\n    return helper() * 2;\n}\n\nint main() {\n    int result = process();\n    int value = helper();\n    return 0;\n}\n\"#;\n\n    let mut parser = CParser::new().expect(\"Failed to create C parser\");\n    let calls = parser.find_calls(code);\n\n    println!(\"Found {} function calls:\", calls.len());\n    for (caller, called, range) in &calls {\n        println!(\"  In '{}': calls '{}' at line {}\", caller, called, range.start_line);\n    }\n\n    // Note: Current implementation uses empty string for caller as we don't track containing functions\n    assert!(\n        calls.iter().any(|(_caller, called, _)| called == &\"helper\"),\n        \"Should find calls to helper function\"\n    );\n\n    assert!(\n        calls.iter().any(|(_caller, called, _)| called == &\"process\"),\n        \"Should find calls to process function\"\n    );\n\n    println!(\"✓ Function calls tracked correctly\");\n}\n\n#[test]\nfn test_c_parser_find_uses() {\n    println!(\"\\n=== C Parser find_uses() Test ===\\n\");\n\n    let code = r#\"\n#define MAX_SIZE 100\n\nint global_var = 42;\n\nint main() {\n    int local_var = global_var;\n    int result = local_var + MAX_SIZE;\n    return 0;\n}\n\"#;\n\n    let mut parser = CParser::new().expect(\"Failed to create C parser\");\n    let uses = parser.find_uses(code);\n\n    println!(\"Found {} variable/function uses:\", uses.len());\n    for (context, used, range) in &uses {\n        println!(\"  Uses '{}' in context '{}' at line {}\", used, context, range.start_line);\n    }\n\n    // Current implementation tracks identifiers\n    assert!(\n        uses.iter().any(|(_, used, _)| used == &\"global_var\"),\n        \"Should find uses of global_var\"\n    );\n\n    assert!(\n        uses.iter().any(|(_, used, _)| used == &\"local_var\"),\n        \"Should find uses of local_var\"\n    );\n\n    assert!(\n        uses.iter().any(|(_, used, _)| used == &\"MAX_SIZE\"),\n        \"Should find uses of MAX_SIZE\"\n    );\n\n    println!(\"✓ Variable and macro uses tracked correctly\");\n}\n\n#[test]\nfn test_c_parser_find_defines() {\n    println!(\"\\n=== C Parser find_defines() Test ===\\n\");\n\n    let code = r#\"\n#define MAX_SIZE 100\n#define SQUARE(x) ((x) * (x))\n\nint global_var = 42;\n\nint main() {\n    int local_var = 10;\n    int squared = SQUARE(5);\n    return 0;\n}\n\"#;\n\n    let mut parser = CParser::new().expect(\"Failed to create C parser\");\n    let defines = parser.find_defines(code);\n\n    println!(\"Found {} definitions:\", defines.len());\n    for (name, kind, range) in &defines {\n        println!(\"  Defines '{}' as {} at line {}\", name, kind, range.start_line);\n    }\n\n    // Should find macro definitions\n    assert!(\n        defines.iter().any(|(name, kind, _)| name == &\"MAX_SIZE\" && kind == &\"macro\"),\n        \"Should find MAX_SIZE macro definition\"\n    );\n\n    assert!(\n        defines.iter().any(|(name, kind, _)| name == &\"SQUARE\" && kind == &\"macro\"),\n        \"Should find SQUARE macro definition\"\n    );\n\n    // Should find variable definitions\n    assert!(\n        defines.iter().any(|(name, kind, _)| name == &\"global_var = 42\" && kind == &\"variable\"),\n        \"Should find global_var definition\"\n    );\n\n    assert!(\n        defines.iter().any(|(name, kind, _)| name == &\"local_var = 10\" && kind == &\"variable\"),\n        \"Should find local_var definition\"\n    );\n\n    println!(\"✓ Variable and macro definitions tracked correctly\");\n}\n\n#[test]\nfn test_c_parser_find_imports() {\n    println!(\"\\n=== C Parser find_imports() Test ===\\n\");\n\n    let code = r#\"\n#include <stdio.h>\n#include <stdlib.h>\n#include \"my_header.h\"\n#include <math.h>\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\n\"#;\n\n    let mut parser = CParser::new().expect(\"Failed to create C parser\");\n    let imports = parser.find_imports(code, codanna::FileId::new(1).unwrap());\n\n    println!(\"Found {} imports:\", imports.len());\n    for import in &imports {\n        println!(\"  Imports '{}'\", import.path);\n    }\n\n    // Should find standard library includes\n    assert!(\n        imports.iter().any(|import| import.path == \"stdio.h\"),\n        \"Should find stdio.h import\"\n    );\n\n    assert!(\n        imports.iter().any(|import| import.path == \"stdlib.h\"),\n        \"Should find stdlib.h import\"\n    );\n\n    assert!(\n        imports.iter().any(|import| import.path == \"math.h\"),\n        \"Should find math.h import\"\n    );\n\n    // Should find local header includes\n    assert!(\n        imports.iter().any(|import| import.path == \"my_header.h\"),\n        \"Should find my_header.h import\"\n    );\n\n    println!(\"✓ Import statements parsed correctly\");\n}
