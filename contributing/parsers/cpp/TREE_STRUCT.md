# C++ AST Tree Structure

Complete nested structure from comprehensive.cpp

```
translation_unit [219] = '/**'
  comment [177] = '/**'
  preproc_include [222] = '#include <iostream>'
    #include [2] = '#include'
    path: system_lib_string [172] = '<iostream>'
  preproc_include [222] = '#include <vector>'
    #include [2] = '#include'
    path: system_lib_string [172] = '<vector>'
  preproc_include [222] = '#include <memory>'
    #include [2] = '#include'
    path: system_lib_string [172] = '<memory>'
  preproc_include [222] = '#include <string>'
    #include [2] = '#include'
    path: system_lib_string [172] = '<string>'
  preproc_include [222] = '#include <algorithm>'
    #include [2] = '#include'
    path: system_lib_string [172] = '<algorithm>'
  preproc_include [222] = '#include <functional>'
    #include [2] = '#include'
    path: system_lib_string [172] = '<functional>'
  preproc_include [222] = '#include <exception>'
    #include [2] = '#include'
    path: system_lib_string [172] = '<exception>'
  comment [177] = '/**'
  namespace_definition [430] = 'namespace geometry {'
    namespace [196] = 'namespace'
    name: namespace_identifier [539] = 'geometry'
    body: declaration_list [270] = '{'
      { [65] = '{'
      comment [177] = '/**'
      class_specifier [379] = 'class Shape {'
        class [98] = 'class'
        name: type_identifier [542] = 'Shape'
        body: field_declaration_list [305] = '{'
          { [65] = '{'
          access_specifier [411] = 'public'
            public [191] = 'public'
          : [101] = ':'
          comment [177] = '/**'
          function_definition [254] = 'virtual ~Shape() = default;'
            virtual [45] = 'virtual'
            declarator: function_declarator [286] = '~Shape()'
              declarator: destructor_name [479] = '~Shape'
                ~ [23] = '~'
                identifier [1] = 'Shape'
              parameters: parameter_list [310] = '()'
                ( [5] = '('
                ) [8] = ')'
            default_method_clause [407] = '= default;'
              = [74] = '='
              default [106] = 'default'
              ; [42] = ';'
          comment [177] = '/**'
          field_declaration [307] = 'virtual double area() const = 0;'
            virtual [45] = 'virtual'
            type: primitive_type [96] = 'double'
            declarator: function_declarator [286] = 'area() const'
              declarator: field_identifier [538] = 'area'
              parameters: parameter_list [310] = '()'
                ( [5] = '('
                ) [8] = ')'
              type_qualifier [297] = 'const'
                const [82] = 'const'
            = [74] = '='
            default_value: number_literal [158] = '0'
            ; [42] = ';'
          comment [177] = '/**'
          function_definition [254]
            virtual [45] = 'virtual'
            type: primitive_type [96] = 'double'
            declarator: function_declarator [286] = 'perimeter() const'
              declarator: field_identifier [538] = 'perimeter'
              parameters: parameter_list [310] = '()'
                ( [5] = '('
                ) [8] = ')'
              type_qualifier [297] = 'const'
                const [82] = 'const'
            body: compound_statement [295] = '{ return 0.0; }'
              { [65] = '{'
              return_statement [326] = 'return 0.0;'
                return [110] = 'return'
                number_literal [158] = '0.0'
                ; [42] = ';'
              } [66] = '}'
          comment [177] = '/**'
          function_definition [254] = 'void display() const {'
            type: primitive_type [96] = 'void'
            declarator: function_declarator [286] = 'display() const'
              declarator: field_identifier [538] = 'display'
              parameters: parameter_list [310] = '()'
                ( [5] = '('
                ) [8] = ')'
              type_qualifier [297] = 'const'
                const [82] = 'const'
            body: compound_statement [295] = '{'
              { [65] = '{'
              expression_statement [317]
                binary_expression [341]
                  left: binary_expression [341]
                    left: binary_expression [341] = 'std::cout << "Shape with area: "'
                      left: qualified_identifier [485] = 'std::cout'
                        scope: namespace_identifier [539] = 'std'
                        :: [49] = '::'
                        name: identifier [1] = 'cout'
                      operator: << [40] = '<<'
                      right: string_literal [371] = '"Shape with area: "'
                        " [169] = '"'
                        string_content [170] = 'Shape with area: '
                        " [169] = '"'
                    operator: << [40] = '<<'
                    right: call_expression [350] = 'area()'
                      function: identifier [1] = 'area'
                      arguments: argument_list [360] = '()'
                        ( [5] = '('
                        ) [8] = ')'
                  operator: << [40] = '<<'
                  right: qualified_identifier [485] = 'std::endl'
                    scope: namespace_identifier [539] = 'std'
                    :: [49] = '::'
                    name: identifier [1] = 'endl'
                ; [42] = ';'
              } [66] = '}'
          } [66] = '}'
      ; [42] = ';'
      comment [177] = '/**'
      class_specifier [379] = 'class Circle : public Shape {'
        class [98] = 'class'
        name: type_identifier [542] = 'Circle'
        base_class_clause [383] = ': public Shape'
          : [101] = ':'
          access_specifier [411] = 'public'
            public [191] = 'public'
          type_identifier [542] = 'Shape'
        body: field_declaration_list [305] = '{'
          { [65] = '{'
          access_specifier [411] = 'private'
            private [192] = 'private'
          : [101] = ':'
          field_declaration [307] = 'double radius_;'
            type: primitive_type [96] = 'double'
            declarator: field_identifier [538] = 'radius_'
            ; [42] = ';'
          comment [177] = '///< Circle radius'
          access_specifier [411] = 'public'
            public [191] = 'public'
          : [101] = ':'
          comment [177] = '/**'
          function_definition [254]
            explicit_function_specifier [382] = 'explicit'
              explicit [182] = 'explicit'
            declarator: function_declarator [286] = 'Circle(double r)'
              declarator: identifier [1] = 'Circle'
              parameters: parameter_list [310] = '(double r)'
                ( [5] = '('
                parameter_declaration [311] = 'double r'
                  type: primitive_type [96] = 'double'
                  declarator: identifier [1] = 'r'
                ) [8] = ')'
            field_initializer_list [398] = ': radius_(r)'
              : [101] = ':'
              field_initializer [399] = 'radius_(r)'
                field_identifier [538] = 'radius_'
                argument_list [360] = '(r)'
                  ( [5] = '('
                  identifier [1] = 'r'
                  ) [8] = ')'
            body: compound_statement [295] = '{}'
              { [65] = '{'
              } [66] = '}'
          comment [177] = '/**'
          function_definition [254] = 'double area() const override {'
            type: primitive_type [96] = 'double'
            declarator: function_declarator [286] = 'area() const override'
              declarator: field_identifier [538] = 'area'
              parameters: parameter_list [310] = '()'
                ( [5] = '('
                ) [8] = ')'
              type_qualifier [297] = 'const'
                const [82] = 'const'
              virtual_specifier [381] = 'override'
                override [181] = 'override'
            body: compound_statement [295] = '{'
              { [65] = '{'
              return_statement [326] = 'return 3.14159 * radius_ * radius_;'
                return [110] = 'return'
                binary_expression [341] = '3.14159 * radius_ * radius_'
                  left: binary_expression [341] = '3.14159 * radius_'
                    left: number_literal [158] = '3.14159'
                    operator: * [26] = '*'
                    right: identifier [1] = 'radius_'
                  operator: * [26] = '*'
                  right: identifier [1] = 'radius_'
                ; [42] = ';'
              } [66] = '}'
          comment [177] = '/**'
          function_definition [254] = 'double perimeter() const override {'
            type: primitive_type [96] = 'double'
            declarator: function_declarator [286] = 'perimeter() const override'
              declarator: field_identifier [538] = 'perimeter'
              parameters: parameter_list [310] = '()'
                ( [5] = '('
                ) [8] = ')'
              type_qualifier [297] = 'const'
                const [82] = 'const'
              virtual_specifier [381] = 'override'
                override [181] = 'override'
            body: compound_statement [295] = '{'
              { [65] = '{'
              return_statement [326] = 'return 2 * 3.14159 * radius_;'
                return [110] = 'return'
                binary_expression [341] = '2 * 3.14159 * radius_'
                  left: binary_expression [341] = '2 * 3.14159'
                    left: number_literal [158] = '2'
                    operator: * [26] = '*'
                    right: number_literal [158] = '3.14159'
                  operator: * [26] = '*'
                  right: identifier [1] = 'radius_'
                ; [42] = ';'
              } [66] = '}'
          comment [177] = '/**'
          function_definition [254]
            type: primitive_type [96] = 'double'
            declarator: function_declarator [286] = 'radius() const noexcept'
              declarator: field_identifier [538] = 'radius'
              parameters: parameter_list [310] = '()'
                ( [5] = '('
                ) [8] = ')'
              type_qualifier [297] = 'const'
                const [82] = 'const'
              noexcept [424] = 'noexcept'
                noexcept [194] = 'noexcept'
            body: compound_statement [295] = '{ return radius_; }'
              { [65] = '{'
              return_statement [326] = 'return radius_;'
                return [110] = 'return'
                identifier [1] = 'radius_'
                ; [42] = ';'
              } [66] = '}'
          } [66] = '}'
      ; [42] = ';'
      comment [177] = '/**'
      class_specifier [379] = 'class Rectangle : public Shape {'
        class [98] = 'class'
        name: type_identifier [542] = 'Rectangle'
        base_class_clause [383] = ': public Shape'
          : [101] = ':'
          access_specifier [411] = 'public'
            public [191] = 'public'
          type_identifier [542] = 'Shape'
        body: field_declaration_list [305] = '{'
          { [65] = '{'
          access_specifier [411] = 'private'
            private [192] = 'private'
          : [101] = ':'
          field_declaration [307] = 'double width_, height_;'
            type: primitive_type [96] = 'double'
            declarator: field_identifier [538] = 'width_'
            , [7] = ','
            declarator: field_identifier [538] = 'height_'
            ; [42] = ';'
          access_specifier [411] = 'public'
            public [191] = 'public'
          : [101] = ':'
          function_definition [254]
            declarator: function_declarator [286] = 'Rectangle(double w, double h)'
              declarator: identifier [1] = 'Rectangle'
              parameters: parameter_list [310] = '(double w, double h)'
                ( [5] = '('
                parameter_declaration [311] = 'double w'
                  type: primitive_type [96] = 'double'
                  declarator: identifier [1] = 'w'
                , [7] = ','
                parameter_declaration [311] = 'double h'
                  type: primitive_type [96] = 'double'
                  declarator: identifier [1] = 'h'
                ) [8] = ')'
            field_initializer_list [398] = ': width_(w), height_(h)'
              : [101] = ':'
              field_initializer [399] = 'width_(w)'
                field_identifier [538] = 'width_'
                argument_list [360] = '(w)'
                  ( [5] = '('
                  identifier [1] = 'w'
                  ) [8] = ')'
              , [7] = ','
              field_initializer [399] = 'height_(h)'
                field_identifier [538] = 'height_'
                argument_list [360] = '(h)'
                  ( [5] = '('
                  identifier [1] = 'h'
                  ) [8] = ')'
            body: compound_statement [295] = '{}'
              { [65] = '{'
              } [66] = '}'
          function_definition [254] = 'double area() const override {'
            type: primitive_type [96] = 'double'
            declarator: function_declarator [286] = 'area() const override'
              declarator: field_identifier [538] = 'area'
              parameters: parameter_list [310] = '()'
                ( [5] = '('
                ) [8] = ')'
              type_qualifier [297] = 'const'
                const [82] = 'const'
              virtual_specifier [381] = 'override'
                override [181] = 'override'
            body: compound_statement [295] = '{'
              { [65] = '{'
              return_statement [326] = 'return width_ * height_;'
                return [110] = 'return'
                binary_expression [341] = 'width_ * height_'
                  left: identifier [1] = 'width_'
                  operator: * [26] = '*'
                  right: identifier [1] = 'height_'
                ; [42] = ';'
              } [66] = '}'
          function_definition [254] = 'double perimeter() const override {'
            type: primitive_type [96] = 'double'
            declarator: function_declarator [286] = 'perimeter() const override'
              declarator: field_identifier [538] = 'perimeter'
              parameters: parameter_list [310] = '()'
                ( [5] = '('
                ) [8] = ')'
              type_qualifier [297] = 'const'
                const [82] = 'const'
              virtual_specifier [381] = 'override'
                override [181] = 'override'
            body: compound_statement [295] = '{'
              { [65] = '{'
              return_statement [326] = 'return 2 * (width_ + height_);'
                return [110] = 'return'
                binary_expression [341] = '2 * (width_ + height_)'
                  left: number_literal [158] = '2'
                  operator: * [26] = '*'
                  right: parenthesized_expression [363] = '(width_ + height_)'
                    ( [5] = '('
                    binary_expression [341] = 'width_ + height_'
                      left: identifier [1] = 'width_'
                      operator: + [25] = '+'
                      right: identifier [1] = 'height_'
                    ) [8] = ')'
                ; [42] = ';'
              } [66] = '}'
          } [66] = '}'
      ; [42] = ';'
      } [66] = '}'
  comment [177] = '// namespace geometry'
  comment [177] = '/**'
  namespace_definition [430] = 'namespace utils {'
    namespace [196] = 'namespace'
    name: namespace_identifier [539] = 'utils'
    body: declaration_list [270] = '{'
      { [65] = '{'
      comment [177] = '/**'
      template_declaration [386] = 'template<typename T>'
        template [184] = 'template'
        parameters: template_parameter_list [388] = '<typename T>'
          < [39] = '<'
          type_parameter_declaration [389] = 'typename T'
            typename [183] = 'typename'
            type_identifier [542] = 'T'
          > [36] = '>'
        function_definition [254]
          type_qualifier [297] = 'constexpr'
            constexpr [83] = 'constexpr'
          type: type_identifier [542] = 'T'
          declarator: function_declarator [286] = 'max(const T& a, const T& b)'
            declarator: identifier [1] = 'max'
            parameters: parameter_list [310] = '(const T& a, const T& b)'
              ( [5] = '('
              parameter_declaration [311] = 'const T& a'
                type_qualifier [297] = 'const'
                  const [82] = 'const'
                type: type_identifier [542] = 'T'
                declarator: reference_declarator [412] = '& a'
                  & [33] = '&'
                  identifier [1] = 'a'
              , [7] = ','
              parameter_declaration [311] = 'const T& b'
                type_qualifier [297] = 'const'
                  const [82] = 'const'
                type: type_identifier [542] = 'T'
                declarator: reference_declarator [412] = '& b'
                  & [33] = '&'
                  identifier [1] = 'b'
              ) [8] = ')'
          body: compound_statement [295] = '{'
            { [65] = '{'
            return_statement [326] = 'return (a > b) ? a : b;'
              return [110] = 'return'
              conditional_expression [337] = '(a > b) ? a : b'
                condition: parenthesized_expression [363] = '(a > b)'
                  ( [5] = '('
                  binary_expression [341] = 'a > b'
                    left: identifier [1] = 'a'
                    operator: > [36] = '>'
                    right: identifier [1] = 'b'
                  ) [8] = ')'
                ? [118] = '?'
                consequence: identifier [1] = 'a'
                : [101] = ':'
                alternative: identifier [1] = 'b'
              ; [42] = ';'
            } [66] = '}'
      comment [177] = '/**'
      template_declaration [386]
        template [184] = 'template'
        parameters: template_parameter_list [388] = '<class Container, class Predicate>'
          < [39] = '<'
          type_parameter_declaration [389] = 'class Container'
            class [98] = 'class'
            type_identifier [542] = 'Container'
          , [7] = ','
          type_parameter_declaration [389] = 'class Predicate'
            class [98] = 'class'
            type_identifier [542] = 'Predicate'
          > [36] = '>'
        function_definition [254]
          type: placeholder_type_specifier [374] = 'auto'
            auto [178] = 'auto'
          declarator: function_declarator [286]
            declarator: identifier [1] = 'filter'
            parameters: parameter_list [310]
              ( [5] = '('
              parameter_declaration [311] = 'const Container& container'
                type_qualifier [297] = 'const'
                  const [82] = 'const'
                type: type_identifier [542] = 'Container'
                declarator: reference_declarator [412] = '& container'
                  & [33] = '&'
                  identifier [1] = 'container'
              , [7] = ','
              parameter_declaration [311] = 'Predicate pred'
                type: type_identifier [542] = 'Predicate'
                declarator: identifier [1] = 'pred'
              ) [8] = ')'
            trailing_return_type [423]
              -> [157] = '->'
              type_descriptor [344]
                type: qualified_identifier [485]
                  scope: namespace_identifier [539] = 'std'
                  :: [49] = '::'
                  name: template_type [426] = 'vector<typename Container::value_type>'
                    name: type_identifier [542] = 'vector'
                    arguments: template_argument_list [429] = '<typename Container::value_type>'
                      < [39] = '<'
                      type_descriptor [344] = 'typename Container::value_type'
                        type: dependent_type [385] = 'typename Container::value_type'
                          typename [183] = 'typename'
                          qualified_identifier [485] = 'Container::value_type'
                            scope: namespace_identifier [539] = 'Container'
                            :: [49] = '::'
                            name: type_identifier [542] = 'value_type'
                      > [36] = '>'
          body: compound_statement [295] = '{'
            { [65] = '{'
            declaration [255]
              type: qualified_identifier [485]
                scope: namespace_identifier [539] = 'std'
                :: [49] = '::'
                name: template_type [426] = 'vector<typename Container::value_type>'
                  name: type_identifier [542] = 'vector'
                  arguments: template_argument_list [429] = '<typename Container::value_type>'
                    < [39] = '<'
                    type_descriptor [344] = 'typename Container::value_type'
                      type: dependent_type [385] = 'typename Container::value_type'
                        typename [183] = 'typename'
                        qualified_identifier [485] = 'Container::value_type'
                          scope: namespace_identifier [539] = 'Container'
                          :: [49] = '::'
                          name: type_identifier [542] = 'value_type'
                    > [36] = '>'
              declarator: identifier [1] = 'result'
              ; [42] = ';'
            expression_statement [317]
              call_expression [350]
                function: qualified_identifier [485] = 'std::copy_if'
                  scope: namespace_identifier [539] = 'std'
                  :: [49] = '::'
                  name: identifier [1] = 'copy_if'
                arguments: argument_list [360] = '(container.begin(), container.end(), '
                  ( [5] = '('
                  call_expression [350] = 'container.begin()'
                    function: field_expression [361] = 'container.begin'
                      argument: identifier [1] = 'container'
                      operator: . [155] = '.'
                      field: field_identifier [538] = 'begin'
                    arguments: argument_list [360] = '()'
                      ( [5] = '('
                      ) [8] = ')'
                  , [7] = ','
                  call_expression [350] = 'container.end()'
                    function: field_expression [361] = 'container.end'
                      argument: identifier [1] = 'container'
                      operator: . [155] = '.'
                      field: field_identifier [538] = 'end'
                    arguments: argument_list [360] = '()'
                      ( [5] = '('
                      ) [8] = ')'
                  , [7] = ','
                  call_expression [350] = 'std::back_inserter(result)'
                    function: qualified_identifier [485] = 'std::back_inserter'
                      scope: namespace_identifier [539] = 'std'
                      :: [49] = '::'
                      name: identifier [1] = 'back_inserter'
                    arguments: argument_list [360] = '(result)'
                      ( [5] = '('
                      identifier [1] = 'result'
                      ) [8] = ')'
                  , [7] = ','
                  identifier [1] = 'pred'
                  ) [8] = ')'
              ; [42] = ';'
            return_statement [326] = 'return result;'
              return [110] = 'return'
              identifier [1] = 'result'
              ; [42] = ';'
            } [66] = '}'
      comment [177] = '/**'
      template_declaration [386] = 'template<>'
        template [184] = 'template'
        parameters: template_parameter_list [388] = '<>'
          < [39] = '<'
          > [36] = '>'
        function_definition [254]
          type_qualifier [297] = 'constexpr'
            constexpr [83] = 'constexpr'
          type: primitive_type [96] = 'int'
          declarator: function_declarator [286] = 'max<int>(const int& a, const int& b)'
            declarator: template_function [428] = 'max<int>'
              name: identifier [1] = 'max'
              arguments: template_argument_list [429] = '<int>'
                < [39] = '<'
                type_descriptor [344] = 'int'
                  type: primitive_type [96] = 'int'
                > [36] = '>'
            parameters: parameter_list [310] = '(const int& a, const int& b)'
              ( [5] = '('
              parameter_declaration [311] = 'const int& a'
                type_qualifier [297] = 'const'
                  const [82] = 'const'
                type: primitive_type [96] = 'int'
                declarator: reference_declarator [412] = '& a'
                  & [33] = '&'
                  identifier [1] = 'a'
              , [7] = ','
              parameter_declaration [311] = 'const int& b'
                type_qualifier [297] = 'const'
                  const [82] = 'const'
                type: primitive_type [96] = 'int'
                declarator: reference_declarator [412] = '& b'
                  & [33] = '&'
                  identifier [1] = 'b'
              ) [8] = ')'
          body: compound_statement [295] = '{'
            { [65] = '{'
            return_statement [326] = 'return (a > b) ? a : b;'
              return [110] = 'return'
              conditional_expression [337] = '(a > b) ? a : b'
                condition: parenthesized_expression [363] = '(a > b)'
                  ( [5] = '('
                  binary_expression [341] = 'a > b'
                    left: identifier [1] = 'a'
                    operator: > [36] = '>'
                    right: identifier [1] = 'b'
                  ) [8] = ')'
                ? [118] = '?'
                consequence: identifier [1] = 'a'
                : [101] = ':'
                alternative: identifier [1] = 'b'
              ; [42] = ';'
            } [66] = '}'
      } [66] = '}'
  comment [177] = '// namespace utils'
  comment [177] = '/**'
  class_specifier [379] = 'class ResourceManager {'
    class [98] = 'class'
    name: type_identifier [542] = 'ResourceManager'
    body: field_declaration_list [305] = '{'
      { [65] = '{'
      access_specifier [411] = 'private'
        private [192] = 'private'
      : [101] = ':'
      field_declaration [307] = 'std::unique_ptr<int[]> data_;'
        type: qualified_identifier [485] = 'std::unique_ptr<int[]>'
          scope: namespace_identifier [539] = 'std'
          :: [49] = '::'
          name: template_type [426] = 'unique_ptr<int[]>'
            name: type_identifier [542] = 'unique_ptr'
            arguments: template_argument_list [429] = '<int[]>'
              < [39] = '<'
              type_descriptor [344] = 'int[]'
                type: primitive_type [96] = 'int'
                declarator: abstract_array_declarator [293] = '[]'
                  [ [71] = '['
                  ] [73] = ']'
              > [36] = '>'
        declarator: field_identifier [538] = 'data_'
        ; [42] = ';'
      field_declaration [307] = 'size_t size_;'
        type: primitive_type [96] = 'size_t'
        declarator: field_identifier [538] = 'size_'
        ; [42] = ';'
      access_specifier [411] = 'public'
        public [191] = 'public'
      : [101] = ':'
      comment [177] = '/**'
      function_definition [254] = 'explicit ResourceManager(size_t size) '
        explicit_function_specifier [382] = 'explicit'
          explicit [182] = 'explicit'
        declarator: function_declarator [286] = 'ResourceManager(size_t size)'
          declarator: identifier [1] = 'ResourceManager'
          parameters: parameter_list [310] = '(size_t size)'
            ( [5] = '('
            parameter_declaration [311] = 'size_t size'
              type: primitive_type [96] = 'size_t'
              declarator: identifier [1] = 'size'
            ) [8] = ')'
        field_initializer_list [398]
          : [101] = ':'
          field_initializer [399] = 'data_(std::make_unique<int[]>(size))'
            field_identifier [538] = 'data_'
            argument_list [360] = '(std::make_unique<int[]>(size))'
              ( [5] = '('
              call_expression [350] = 'std::make_unique<int[]>(size)'
                function: qualified_identifier [485] = 'std::make_unique<int[]>'
                  scope: namespace_identifier [539] = 'std'
                  :: [49] = '::'
                  name: template_function [428] = 'make_unique<int[]>'
                    name: identifier [1] = 'make_unique'
                    arguments: template_argument_list [429] = '<int[]>'
                      < [39] = '<'
                      type_descriptor [344] = 'int[]'
                        type: primitive_type [96] = 'int'
                        declarator: abstract_array_declarator [293] = '[]'
                          [ [71] = '['
                          ] [73] = ']'
                      > [36] = '>'
                arguments: argument_list [360] = '(size)'
                  ( [5] = '('
                  identifier [1] = 'size'
                  ) [8] = ')'
              ) [8] = ')'
          , [7] = ','
          field_initializer [399] = 'size_(size)'
            field_identifier [538] = 'size_'
            argument_list [360] = '(size)'
              ( [5] = '('
              identifier [1] = 'size'
              ) [8] = ')'
        body: compound_statement [295] = '{'
          { [65] = '{'
          expression_statement [317]
            binary_expression [341]
              left: binary_expression [341]
                left: binary_expression [341]
                  left: qualified_identifier [485] = 'std::cout'
                    scope: namespace_identifier [539] = 'std'
                    :: [49] = '::'
                    name: identifier [1] = 'cout'
                  operator: << [40] = '<<'
                  right: string_literal [371] = '"ResourceManager allocated "'
                    " [169] = '"'
                    string_content [170] = 'ResourceManager allocated '
                    " [169] = '"'
                operator: << [40] = '<<'
                right: identifier [1] = 'size'
              operator: << [40] = '<<'
              right: string_literal [371] = '" integers\n"'
                " [169] = '"'
                string_content [170] = ' integers'
                escape_sequence [171] = '\n'
                " [169] = '"'
            ; [42] = ';'
          } [66] = '}'
      comment [177] = '/**'
      function_definition [254]
        declarator: function_declarator [286]
          declarator: identifier [1] = 'ResourceManager'
          parameters: parameter_list [310] = '(ResourceManager&& other)'
            ( [5] = '('
            parameter_declaration [311] = 'ResourceManager&& other'
              type: type_identifier [542] = 'ResourceManager'
              declarator: reference_declarator [412] = '&& other'
                && [30] = '&&'
                identifier [1] = 'other'
            ) [8] = ')'
          noexcept [424] = 'noexcept'
            noexcept [194] = 'noexcept'
        field_initializer_list [398]
          : [101] = ':'
          field_initializer [399] = 'data_(std::move(other.data_))'
            field_identifier [538] = 'data_'
            argument_list [360] = '(std::move(other.data_))'
              ( [5] = '('
              call_expression [350] = 'std::move(other.data_)'
                function: qualified_identifier [485] = 'std::move'
                  scope: namespace_identifier [539] = 'std'
                  :: [49] = '::'
                  name: identifier [1] = 'move'
                arguments: argument_list [360] = '(other.data_)'
                  ( [5] = '('
                  field_expression [361] = 'other.data_'
                    argument: identifier [1] = 'other'
                    operator: . [155] = '.'
                    field: field_identifier [538] = 'data_'
                  ) [8] = ')'
              ) [8] = ')'
          , [7] = ','
          field_initializer [399] = 'size_(other.size_)'
            field_identifier [538] = 'size_'
            argument_list [360] = '(other.size_)'
              ( [5] = '('
              field_expression [361] = 'other.size_'
                argument: identifier [1] = 'other'
                operator: . [155] = '.'
                field: field_identifier [538] = 'size_'
              ) [8] = ')'
        body: compound_statement [295] = '{'
          { [65] = '{'
          expression_statement [317] = 'other.size_ = 0;'
            assignment_expression [338] = 'other.size_ = 0'
              left: field_expression [361] = 'other.size_'
                argument: identifier [1] = 'other'
                operator: . [155] = '.'
                field: field_identifier [538] = 'size_'
              operator: = [74] = '='
              right: number_literal [158] = '0'
            ; [42] = ';'
          } [66] = '}'
      comment [177] = '/**'
      function_definition [254]
        type: type_identifier [542] = 'ResourceManager'
        declarator: reference_declarator [412]
          & [33] = '&'
          function_declarator [286]
            declarator: operator_name [489] = 'operator='
              operator [186] = 'operator'
              = [74] = '='
            parameters: parameter_list [310] = '(ResourceManager&& other)'
              ( [5] = '('
              parameter_declaration [311] = 'ResourceManager&& other'
                type: type_identifier [542] = 'ResourceManager'
                declarator: reference_declarator [412] = '&& other'
                  && [30] = '&&'
                  identifier [1] = 'other'
              ) [8] = ')'
            noexcept [424] = 'noexcept'
              noexcept [194] = 'noexcept'
        body: compound_statement [295] = '{'
          { [65] = '{'
          if_statement [318] = 'if (this != &other) {'
            if [102] = 'if'
            condition: condition_clause [441] = '(this != &other)'
              ( [5] = '('
              value: binary_expression [341] = 'this != &other'
                left: this [215] = 'this'
                operator: != [35] = '!='
                right: pointer_expression [339] = '&other'
                  operator: & [33] = '&'
                  argument: identifier [1] = 'other'
              ) [8] = ')'
            consequence: compound_statement [295] = '{'
              { [65] = '{'
              expression_statement [317] = 'data_ = std::move(other.data_);'
                assignment_expression [338] = 'data_ = std::move(other.data_)'
                  left: identifier [1] = 'data_'
                  operator: = [74] = '='
                  right: call_expression [350] = 'std::move(other.data_)'
                    function: qualified_identifier [485] = 'std::move'
                      scope: namespace_identifier [539] = 'std'
                      :: [49] = '::'
                      name: identifier [1] = 'move'
                    arguments: argument_list [360] = '(other.data_)'
                      ( [5] = '('
                      field_expression [361] = 'other.data_'
                        argument: identifier [1] = 'other'
                        operator: . [155] = '.'
                        field: field_identifier [538] = 'data_'
                      ) [8] = ')'
                ; [42] = ';'
              expression_statement [317] = 'size_ = other.size_;'
                assignment_expression [338] = 'size_ = other.size_'
                  left: identifier [1] = 'size_'
                  operator: = [74] = '='
                  right: field_expression [361] = 'other.size_'
                    argument: identifier [1] = 'other'
                    operator: . [155] = '.'
                    field: field_identifier [538] = 'size_'
                ; [42] = ';'
              expression_statement [317] = 'other.size_ = 0;'
                assignment_expression [338] = 'other.size_ = 0'
                  left: field_expression [361] = 'other.size_'
                    argument: identifier [1] = 'other'
                    operator: . [155] = '.'
                    field: field_identifier [538] = 'size_'
                  operator: = [74] = '='
                  right: number_literal [158] = '0'
                ; [42] = ';'
              } [66] = '}'
          return_statement [326] = 'return *this;'
            return [110] = 'return'
            pointer_expression [339] = '*this'
              operator: * [26] = '*'
              argument: this [215] = 'this'
            ; [42] = ';'
          } [66] = '}'
      comment [177] = '/**'
      function_definition [254]
        declarator: function_declarator [286] = 'ResourceManager(const ResourceManager&)'
          declarator: identifier [1] = 'ResourceManager'
          parameters: parameter_list [310] = '(const ResourceManager&)'
            ( [5] = '('
            parameter_declaration [311] = 'const ResourceManager&'
              type_qualifier [297] = 'const'
                const [82] = 'const'
              type: type_identifier [542] = 'ResourceManager'
              declarator: abstract_reference_declarator [415] = '&'
                & [33] = '&'
            ) [8] = ')'
        delete_method_clause [408] = '= delete;'
          = [74] = '='
          delete [188] = 'delete'
          ; [42] = ';'
      function_definition [254]
        type: type_identifier [542] = 'ResourceManager'
        declarator: reference_declarator [412] = '& operator=(const ResourceManager&)'
          & [33] = '&'
          function_declarator [286] = 'operator=(const ResourceManager&)'
            declarator: operator_name [489] = 'operator='
              operator [186] = 'operator'
              = [74] = '='
            parameters: parameter_list [310] = '(const ResourceManager&)'
              ( [5] = '('
              parameter_declaration [311] = 'const ResourceManager&'
                type_qualifier [297] = 'const'
                  const [82] = 'const'
                type: type_identifier [542] = 'ResourceManager'
                declarator: abstract_reference_declarator [415] = '&'
                  & [33] = '&'
              ) [8] = ')'
        delete_method_clause [408] = '= delete;'
          = [74] = '='
          delete [188] = 'delete'
          ; [42] = ';'
      comment [177] = '/**'
      function_definition [254] = '~ResourceManager() {'
        declarator: function_declarator [286] = '~ResourceManager()'
          declarator: destructor_name [479] = '~ResourceManager'
            ~ [23] = '~'
            identifier [1] = 'ResourceManager'
          parameters: parameter_list [310] = '()'
            ( [5] = '('
            ) [8] = ')'
        body: compound_statement [295] = '{'
          { [65] = '{'
          if_statement [318] = 'if (size_ > 0) {'
            if [102] = 'if'
            condition: condition_clause [441] = '(size_ > 0)'
              ( [5] = '('
              value: binary_expression [341] = 'size_ > 0'
                left: identifier [1] = 'size_'
                operator: > [36] = '>'
                right: number_literal [158] = '0'
              ) [8] = ')'
            consequence: compound_statement [295] = '{'
              { [65] = '{'
              expression_statement [317]
                binary_expression [341]
                  left: binary_expression [341]
                    left: binary_expression [341]
                      left: qualified_identifier [485] = 'std::cout'
                        scope: namespace_identifier [539] = 'std'
                        :: [49] = '::'
                        name: identifier [1] = 'cout'
                      operator: << [40] = '<<'
                      right: string_literal [371] = '"ResourceManager deallocating "'
                        " [169] = '"'
                        string_content [170] = 'ResourceManager deallocating '
                        " [169] = '"'
                    operator: << [40] = '<<'
                    right: identifier [1] = 'size_'
                  operator: << [40] = '<<'
                  right: string_literal [371] = '" integers\n"'
                    " [169] = '"'
                    string_content [170] = ' integers'
                    escape_sequence [171] = '\n'
                    " [169] = '"'
                ; [42] = ';'
              } [66] = '}'
          } [66] = '}'
      comment [177] = '/**'
      function_definition [254] = 'int& operator[](size_t index) {'
        type: primitive_type [96] = 'int'
        declarator: reference_declarator [412] = '& operator[](size_t index)'
          & [33] = '&'
          function_declarator [286] = 'operator[](size_t index)'
            declarator: operator_name [489] = 'operator[]'
              operator [186] = 'operator'
              [] [213] = '[]'
            parameters: parameter_list [310] = '(size_t index)'
              ( [5] = '('
              parameter_declaration [311] = 'size_t index'
                type: primitive_type [96] = 'size_t'
                declarator: identifier [1] = 'index'
              ) [8] = ')'
        body: compound_statement [295] = '{'
          { [65] = '{'
          return_statement [326] = 'return data_[index];'
            return [110] = 'return'
            subscript_expression [349] = 'data_[index]'
              argument: identifier [1] = 'data_'
              indices: subscript_argument_list [449] = '[index]'
                [ [71] = '['
                identifier [1] = 'index'
                ] [73] = ']'
            ; [42] = ';'
          } [66] = '}'
      comment [177] = '/**'
      function_definition [254]
        type_qualifier [297] = 'const'
          const [82] = 'const'
        type: primitive_type [96] = 'int'
        declarator: reference_declarator [412] = '& operator[](size_t index) const'
          & [33] = '&'
          function_declarator [286] = 'operator[](size_t index) const'
            declarator: operator_name [489] = 'operator[]'
              operator [186] = 'operator'
              [] [213] = '[]'
            parameters: parameter_list [310] = '(size_t index)'
              ( [5] = '('
              parameter_declaration [311] = 'size_t index'
                type: primitive_type [96] = 'size_t'
                declarator: identifier [1] = 'index'
              ) [8] = ')'
            type_qualifier [297] = 'const'
              const [82] = 'const'
        body: compound_statement [295] = '{'
          { [65] = '{'
          return_statement [326] = 'return data_[index];'
            return [110] = 'return'
            subscript_expression [349] = 'data_[index]'
              argument: identifier [1] = 'data_'
              indices: subscript_argument_list [449] = '[index]'
                [ [71] = '['
                identifier [1] = 'index'
                ] [73] = ']'
            ; [42] = ';'
          } [66] = '}'
      function_definition [254]
        type: primitive_type [96] = 'size_t'
        declarator: function_declarator [286] = 'size() const noexcept'
          declarator: field_identifier [538] = 'size'
          parameters: parameter_list [310] = '()'
            ( [5] = '('
            ) [8] = ')'
          type_qualifier [297] = 'const'
            const [82] = 'const'
          noexcept [424] = 'noexcept'
            noexcept [194] = 'noexcept'
        body: compound_statement [295] = '{ return size_; }'
          { [65] = '{'
          return_statement [326] = 'return size_;'
            return [110] = 'return'
            identifier [1] = 'size_'
            ; [42] = ';'
          } [66] = '}'
      } [66] = '}'
  ; [42] = ';'
  comment [177] = '/**'
  class_specifier [379]
    class [98] = 'class'
    name: type_identifier [542] = 'CustomException'
    base_class_clause [383] = ': public std::exception'
      : [101] = ':'
      access_specifier [411] = 'public'
        public [191] = 'public'
      qualified_identifier [485] = 'std::exception'
        scope: namespace_identifier [539] = 'std'
        :: [49] = '::'
        name: type_identifier [542] = 'exception'
    body: field_declaration_list [305] = '{'
      { [65] = '{'
      access_specifier [411] = 'private'
        private [192] = 'private'
      : [101] = ':'
      field_declaration [307] = 'std::string message_;'
        type: qualified_identifier [485] = 'std::string'
          scope: namespace_identifier [539] = 'std'
          :: [49] = '::'
          name: type_identifier [542] = 'string'
        declarator: field_identifier [538] = 'message_'
        ; [42] = ';'
      access_specifier [411] = 'public'
        public [191] = 'public'
      : [101] = ':'
      function_definition [254]
        explicit_function_specifier [382] = 'explicit'
          explicit [182] = 'explicit'
        declarator: function_declarator [286] = 'CustomException(const std::string& msg)'
          declarator: identifier [1] = 'CustomException'
          parameters: parameter_list [310] = '(const std::string& msg)'
            ( [5] = '('
            parameter_declaration [311] = 'const std::string& msg'
              type_qualifier [297] = 'const'
                const [82] = 'const'
              type: qualified_identifier [485] = 'std::string'
                scope: namespace_identifier [539] = 'std'
                :: [49] = '::'
                name: type_identifier [542] = 'string'
              declarator: reference_declarator [412] = '& msg'
                & [33] = '&'
                identifier [1] = 'msg'
            ) [8] = ')'
        field_initializer_list [398] = ': message_(msg)'
          : [101] = ':'
          field_initializer [399] = 'message_(msg)'
            field_identifier [538] = 'message_'
            argument_list [360] = '(msg)'
              ( [5] = '('
              identifier [1] = 'msg'
              ) [8] = ')'
        body: compound_statement [295] = '{}'
          { [65] = '{'
          } [66] = '}'
      function_definition [254]
        type_qualifier [297] = 'const'
          const [82] = 'const'
        type: primitive_type [96] = 'char'
        declarator: pointer_declarator [282] = '* what() const noexcept override'
          * [26] = '*'
          declarator: function_declarator [286] = 'what() const noexcept override'
            declarator: field_identifier [538] = 'what'
            parameters: parameter_list [310] = '()'
              ( [5] = '('
              ) [8] = ')'
            type_qualifier [297] = 'const'
              const [82] = 'const'
            noexcept [424] = 'noexcept'
              noexcept [194] = 'noexcept'
            virtual_specifier [381] = 'override'
              override [181] = 'override'
        body: compound_statement [295] = '{'
          { [65] = '{'
          return_statement [326] = 'return message_.c_str();'
            return [110] = 'return'
            call_expression [350] = 'message_.c_str()'
              function: field_expression [361] = 'message_.c_str'
                argument: identifier [1] = 'message_'
                operator: . [155] = '.'
                field: field_identifier [538] = 'c_str'
              arguments: argument_list [360] = '()'
                ( [5] = '('
                ) [8] = ')'
            ; [42] = ';'
          } [66] = '}'
      } [66] = '}'
  ; [42] = ';'
  comment [177] = '/**'
  function_definition [254]
    type: primitive_type [96] = 'void'
    declarator: function_declarator [286]
      declarator: identifier [1] = 'demonstrate_exceptions'
      parameters: parameter_list [310] = '(bool risky_operation)'
        ( [5] = '('
        parameter_declaration [311] = 'bool risky_operation'
          type: primitive_type [96] = 'bool'
          declarator: identifier [1] = 'risky_operation'
        ) [8] = ')'
    body: compound_statement [295] = '{'
      { [65] = '{'
      try_statement [446] = 'try {'
        try [187] = 'try'
        body: compound_statement [295] = '{'
          { [65] = '{'
          declaration [255] = 'ResourceManager manager(10);'
            type: type_identifier [542] = 'ResourceManager'
            declarator: init_declarator [294] = 'manager(10)'
              declarator: identifier [1] = 'manager'
              value: argument_list [360] = '(10)'
                ( [5] = '('
                number_literal [158] = '10'
                ) [8] = ')'
            ; [42] = ';'
          if_statement [318] = 'if (risky_operation) {'
            if [102] = 'if'
            condition: condition_clause [441] = '(risky_operation)'
              ( [5] = '('
              value: identifier [1] = 'risky_operation'
              ) [8] = ')'
            consequence: compound_statement [295] = '{'
              { [65] = '{'
              throw_statement [445]
                throw [195] = 'throw'
                call_expression [350]
                  function: identifier [1] = 'CustomException'
                  arguments: argument_list [360] = '("Simulated error in operation")'
                    ( [5] = '('
                    string_literal [371] = '"Simulated error in operation"'
                      " [169] = '"'
                      string_content [170] = 'Simulated error in operation'
                      " [169] = '"'
                    ) [8] = ')'
                ; [42] = ';'
              } [66] = '}'
          comment [177] = '// Use the resource'
          for_statement [324]
            for [109] = 'for'
            ( [5] = '('
            initializer: declaration [255] = 'size_t i = 0;'
              type: primitive_type [96] = 'size_t'
              declarator: init_declarator [294] = 'i = 0'
                declarator: identifier [1] = 'i'
                = [74] = '='
                value: number_literal [158] = '0'
              ; [42] = ';'
            condition: binary_expression [341] = 'i < manager.size()'
              left: identifier [1] = 'i'
              operator: < [39] = '<'
              right: call_expression [350] = 'manager.size()'
                function: field_expression [361] = 'manager.size'
                  argument: identifier [1] = 'manager'
                  operator: . [155] = '.'
                  field: field_identifier [538] = 'size'
                arguments: argument_list [360] = '()'
                  ( [5] = '('
                  ) [8] = ')'
            ; [42] = ';'
            update: update_expression [342] = '++i'
              operator: ++ [142] = '++'
              argument: identifier [1] = 'i'
            ) [8] = ')'
            body: compound_statement [295] = '{'
              { [65] = '{'
              expression_statement [317] = 'manager[i] = static_cast<int>(i * i);'
                assignment_expression [338] = 'manager[i] = static_cast<int>(i * i)'
                  left: subscript_expression [349] = 'manager[i]'
                    argument: identifier [1] = 'manager'
                    indices: subscript_argument_list [449] = '[i]'
                      [ [71] = '['
                      identifier [1] = 'i'
                      ] [73] = ']'
                  operator: = [74] = '='
                  right: call_expression [350] = 'static_cast<int>(i * i)'
                    function: template_function [428] = 'static_cast<int>'
                      name: identifier [1] = 'static_cast'
                      arguments: template_argument_list [429] = '<int>'
                        < [39] = '<'
                        type_descriptor [344] = 'int'
                          type: primitive_type [96] = 'int'
                        > [36] = '>'
                    arguments: argument_list [360] = '(i * i)'
                      ( [5] = '('
                      binary_expression [341] = 'i * i'
                        left: identifier [1] = 'i'
                        operator: * [26] = '*'
                        right: identifier [1] = 'i'
                      ) [8] = ')'
                ; [42] = ';'
              } [66] = '}'
          } [66] = '}'
        catch_clause [447] = 'catch (const CustomException& e) {'
          catch [202] = 'catch'
          parameters: parameter_list [310] = '(const CustomException& e)'
            ( [5] = '('
            parameter_declaration [311] = 'const CustomException& e'
              type_qualifier [297] = 'const'
                const [82] = 'const'
              type: type_identifier [542] = 'CustomException'
              declarator: reference_declarator [412] = '& e'
                & [33] = '&'
                identifier [1] = 'e'
            ) [8] = ')'
          body: compound_statement [295] = '{'
            { [65] = '{'
            expression_statement [317]
              binary_expression [341]
                left: binary_expression [341]
                  left: binary_expression [341] = 'std::cerr << "Custom exception caught: "'
                    left: qualified_identifier [485] = 'std::cerr'
                      scope: namespace_identifier [539] = 'std'
                      :: [49] = '::'
                      name: identifier [1] = 'cerr'
                    operator: << [40] = '<<'
                    right: string_literal [371] = '"Custom exception caught: "'
                      " [169] = '"'
                      string_content [170] = 'Custom exception caught: '
                      " [169] = '"'
                  operator: << [40] = '<<'
                  right: call_expression [350] = 'e.what()'
                    function: field_expression [361] = 'e.what'
                      argument: identifier [1] = 'e'
                      operator: . [155] = '.'
                      field: field_identifier [538] = 'what'
                    arguments: argument_list [360] = '()'
                      ( [5] = '('
                      ) [8] = ')'
                operator: << [40] = '<<'
                right: qualified_identifier [485] = 'std::endl'
                  scope: namespace_identifier [539] = 'std'
                  :: [49] = '::'
                  name: identifier [1] = 'endl'
              ; [42] = ';'
            } [66] = '}'
        catch_clause [447] = 'catch (const std::exception& e) {'
          catch [202] = 'catch'
          parameters: parameter_list [310] = '(const std::exception& e)'
            ( [5] = '('
            parameter_declaration [311] = 'const std::exception& e'
              type_qualifier [297] = 'const'
                const [82] = 'const'
              type: qualified_identifier [485] = 'std::exception'
                scope: namespace_identifier [539] = 'std'
                :: [49] = '::'
                name: type_identifier [542] = 'exception'
              declarator: reference_declarator [412] = '& e'
                & [33] = '&'
                identifier [1] = 'e'
            ) [8] = ')'
          body: compound_statement [295] = '{'
            { [65] = '{'
            expression_statement [317]
              binary_expression [341]
                left: binary_expression [341]
                  left: binary_expression [341]
                    left: qualified_identifier [485] = 'std::cerr'
                      scope: namespace_identifier [539] = 'std'
                      :: [49] = '::'
                      name: identifier [1] = 'cerr'
                    operator: << [40] = '<<'
                    right: string_literal [371] = '"Standard exception caught: "'
                      " [169] = '"'
                      string_content [170] = 'Standard exception caught: '
                      " [169] = '"'
                  operator: << [40] = '<<'
                  right: call_expression [350] = 'e.what()'
                    function: field_expression [361] = 'e.what'
                      argument: identifier [1] = 'e'
                      operator: . [155] = '.'
                      field: field_identifier [538] = 'what'
                    arguments: argument_list [360] = '()'
                      ( [5] = '('
                      ) [8] = ')'
                operator: << [40] = '<<'
                right: qualified_identifier [485] = 'std::endl'
                  scope: namespace_identifier [539] = 'std'
                  :: [49] = '::'
                  name: identifier [1] = 'endl'
              ; [42] = ';'
            } [66] = '}'
      comment [177] = '// RAII ensures ResourceManager destructor is called'
      } [66] = '}'
  comment [177] = '/**'
  function_definition [254] = 'void demonstrate_lambdas() {'
    type: primitive_type [96] = 'void'
    declarator: function_declarator [286] = 'demonstrate_lambdas()'
      declarator: identifier [1] = 'demonstrate_lambdas'
      parameters: parameter_list [310] = '()'
        ( [5] = '('
        ) [8] = ')'
    body: compound_statement [295] = '{'
      { [65] = '{'
      declaration [255]
        type: qualified_identifier [485] = 'std::vector<int>'
          scope: namespace_identifier [539] = 'std'
          :: [49] = '::'
          name: template_type [426] = 'vector<int>'
            name: type_identifier [542] = 'vector'
            arguments: template_argument_list [429] = '<int>'
              < [39] = '<'
              type_descriptor [344] = 'int'
                type: primitive_type [96] = 'int'
              > [36] = '>'
        declarator: init_declarator [294]
          declarator: identifier [1] = 'numbers'
          = [74] = '='
          value: initializer_list [364] = '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}'
            { [65] = '{'
            number_literal [158] = '1'
            , [7] = ','
            number_literal [158] = '2'
            , [7] = ','
            number_literal [158] = '3'
            , [7] = ','
            number_literal [158] = '4'
            , [7] = ','
            number_literal [158] = '5'
            , [7] = ','
            number_literal [158] = '6'
            , [7] = ','
            number_literal [158] = '7'
            , [7] = ','
            number_literal [158] = '8'
            , [7] = ','
            number_literal [158] = '9'
            , [7] = ','
            number_literal [158] = '10'
            } [66] = '}'
        ; [42] = ';'
      comment [177] = '// Lambda with capture by value'
      declaration [255] = 'int multiplier = 2;'
        type: primitive_type [96] = 'int'
        declarator: init_declarator [294] = 'multiplier = 2'
          declarator: identifier [1] = 'multiplier'
          = [74] = '='
          value: number_literal [158] = '2'
        ; [42] = ';'
      declaration [255]
        type: placeholder_type_specifier [374] = 'auto'
          auto [178] = 'auto'
        declarator: init_declarator [294]
          declarator: identifier [1] = 'multiply'
          = [74] = '='
          value: lambda_expression [464]
            captures: lambda_capture_specifier [465] = '[multiplier]'
              [ [71] = '['
              identifier [1] = 'multiplier'
              ] [73] = ']'
            declarator: abstract_function_declarator [289] = '(int x)'
              parameters: parameter_list [310] = '(int x)'
                ( [5] = '('
                parameter_declaration [311] = 'int x'
                  type: primitive_type [96] = 'int'
                  declarator: identifier [1] = 'x'
                ) [8] = ')'
            body: compound_statement [295] = '{ return x * multiplier; }'
              { [65] = '{'
              return_statement [326] = 'return x * multiplier;'
                return [110] = 'return'
                binary_expression [341] = 'x * multiplier'
                  left: identifier [1] = 'x'
                  operator: * [26] = '*'
                  right: identifier [1] = 'multiplier'
                ; [42] = ';'
              } [66] = '}'
        ; [42] = ';'
      comment [177] = '// Lambda with capture by reference'
      declaration [255] = 'int sum = 0;'
        type: primitive_type [96] = 'int'
        declarator: init_declarator [294] = 'sum = 0'
          declarator: identifier [1] = 'sum'
          = [74] = '='
          value: number_literal [158] = '0'
        ; [42] = ';'
      declaration [255]
        type: placeholder_type_specifier [374] = 'auto'
          auto [178] = 'auto'
        declarator: init_declarator [294] = 'accumulate = [&sum](int x) { sum += x; }'
          declarator: identifier [1] = 'accumulate'
          = [74] = '='
          value: lambda_expression [464] = '[&sum](int x) { sum += x; }'
            captures: lambda_capture_specifier [465] = '[&sum]'
              [ [71] = '['
              & [33] = '&'
              identifier [1] = 'sum'
              ] [73] = ']'
            declarator: abstract_function_declarator [289] = '(int x)'
              parameters: parameter_list [310] = '(int x)'
                ( [5] = '('
                parameter_declaration [311] = 'int x'
                  type: primitive_type [96] = 'int'
                  declarator: identifier [1] = 'x'
                ) [8] = ')'
            body: compound_statement [295] = '{ sum += x; }'
              { [65] = '{'
              expression_statement [317] = 'sum += x;'
                assignment_expression [338] = 'sum += x'
                  left: identifier [1] = 'sum'
                  operator: += [122] = '+='
                  right: identifier [1] = 'x'
                ; [42] = ';'
              } [66] = '}'
        ; [42] = ';'
      comment [177] = '// Generic lambda (C++14)'
      declaration [255]
        type: placeholder_type_specifier [374] = 'auto'
          auto [178] = 'auto'
        declarator: init_declarator [294] = 'generic_print = [](const auto& value) {'
          declarator: identifier [1] = 'generic_print'
          = [74] = '='
          value: lambda_expression [464] = '[](const auto& value) {'
            captures: lambda_capture_specifier [465] = '[]'
              [ [71] = '['
              ] [73] = ']'
            declarator: abstract_function_declarator [289] = '(const auto& value)'
              parameters: parameter_list [310] = '(const auto& value)'
                ( [5] = '('
                parameter_declaration [311] = 'const auto& value'
                  type_qualifier [297] = 'const'
                    const [82] = 'const'
                  type: placeholder_type_specifier [374] = 'auto'
                    auto [178] = 'auto'
                  declarator: reference_declarator [412] = '& value'
                    & [33] = '&'
                    identifier [1] = 'value'
                ) [8] = ')'
            body: compound_statement [295] = '{'
              { [65] = '{'
              expression_statement [317] = 'std::cout << value << " ";'
                binary_expression [341] = 'std::cout << value << " "'
                  left: binary_expression [341] = 'std::cout << value'
                    left: qualified_identifier [485] = 'std::cout'
                      scope: namespace_identifier [539] = 'std'
                      :: [49] = '::'
                      name: identifier [1] = 'cout'
                    operator: << [40] = '<<'
                    right: identifier [1] = 'value'
                  operator: << [40] = '<<'
                  right: string_literal [371] = '" "'
                    " [169] = '"'
                    string_content [170] = ' '
                    " [169] = '"'
                ; [42] = ';'
              } [66] = '}'
        ; [42] = ';'
      comment [177] = '// Use lambdas with STL algorithms'
      expression_statement [317]
        call_expression [350]
          function: qualified_identifier [485] = 'std::for_each'
            scope: namespace_identifier [539] = 'std'
            :: [49] = '::'
            name: identifier [1] = 'for_each'
          arguments: argument_list [360]
            ( [5] = '('
            call_expression [350] = 'numbers.begin()'
              function: field_expression [361] = 'numbers.begin'
                argument: identifier [1] = 'numbers'
                operator: . [155] = '.'
                field: field_identifier [538] = 'begin'
              arguments: argument_list [360] = '()'
                ( [5] = '('
                ) [8] = ')'
            , [7] = ','
            call_expression [350] = 'numbers.end()'
              function: field_expression [361] = 'numbers.end'
                argument: identifier [1] = 'numbers'
                operator: . [155] = '.'
                field: field_identifier [538] = 'end'
              arguments: argument_list [360] = '()'
                ( [5] = '('
                ) [8] = ')'
            , [7] = ','
            identifier [1] = 'accumulate'
            ) [8] = ')'
        ; [42] = ';'
      expression_statement [317]
        binary_expression [341] = 'std::cout << "Sum: " << sum << std::endl'
          left: binary_expression [341] = 'std::cout << "Sum: " << sum'
            left: binary_expression [341] = 'std::cout << "Sum: "'
              left: qualified_identifier [485] = 'std::cout'
                scope: namespace_identifier [539] = 'std'
                :: [49] = '::'
                name: identifier [1] = 'cout'
              operator: << [40] = '<<'
              right: string_literal [371] = '"Sum: "'
                " [169] = '"'
                string_content [170] = 'Sum: '
                " [169] = '"'
            operator: << [40] = '<<'
            right: identifier [1] = 'sum'
          operator: << [40] = '<<'
          right: qualified_identifier [485] = 'std::endl'
            scope: namespace_identifier [539] = 'std'
            :: [49] = '::'
            name: identifier [1] = 'endl'
        ; [42] = ';'
      comment [177] = '// Transform with lambda'
      declaration [255] = 'std::vector<int> doubled;'
        type: qualified_identifier [485] = 'std::vector<int>'
          scope: namespace_identifier [539] = 'std'
          :: [49] = '::'
          name: template_type [426] = 'vector<int>'
            name: type_identifier [542] = 'vector'
            arguments: template_argument_list [429] = '<int>'
              < [39] = '<'
              type_descriptor [344] = 'int'
                type: primitive_type [96] = 'int'
              > [36] = '>'
        declarator: identifier [1] = 'doubled'
        ; [42] = ';'
      expression_statement [317]
        call_expression [350]
          function: qualified_identifier [485] = 'std::transform'
            scope: namespace_identifier [539] = 'std'
            :: [49] = '::'
            name: identifier [1] = 'transform'
          arguments: argument_list [360] = '(numbers.begin(), numbers.end(), '
            ( [5] = '('
            call_expression [350] = 'numbers.begin()'
              function: field_expression [361] = 'numbers.begin'
                argument: identifier [1] = 'numbers'
                operator: . [155] = '.'
                field: field_identifier [538] = 'begin'
              arguments: argument_list [360] = '()'
                ( [5] = '('
                ) [8] = ')'
            , [7] = ','
            call_expression [350] = 'numbers.end()'
              function: field_expression [361] = 'numbers.end'
                argument: identifier [1] = 'numbers'
                operator: . [155] = '.'
                field: field_identifier [538] = 'end'
              arguments: argument_list [360] = '()'
                ( [5] = '('
                ) [8] = ')'
            , [7] = ','
            call_expression [350] = 'std::back_inserter(doubled)'
              function: qualified_identifier [485] = 'std::back_inserter'
                scope: namespace_identifier [539] = 'std'
                :: [49] = '::'
                name: identifier [1] = 'back_inserter'
              arguments: argument_list [360] = '(doubled)'
                ( [5] = '('
                identifier [1] = 'doubled'
                ) [8] = ')'
            , [7] = ','
            identifier [1] = 'multiply'
            ) [8] = ')'
        ; [42] = ';'
      expression_statement [317] = 'std::cout << "Doubled: ";'
        binary_expression [341] = 'std::cout << "Doubled: "'
          left: qualified_identifier [485] = 'std::cout'
            scope: namespace_identifier [539] = 'std'
            :: [49] = '::'
            name: identifier [1] = 'cout'
          operator: << [40] = '<<'
          right: string_literal [371] = '"Doubled: "'
            " [169] = '"'
            string_content [170] = 'Doubled: '
            " [169] = '"'
        ; [42] = ';'
      expression_statement [317]
        call_expression [350]
          function: qualified_identifier [485] = 'std::for_each'
            scope: namespace_identifier [539] = 'std'
            :: [49] = '::'
            name: identifier [1] = 'for_each'
          arguments: argument_list [360]
            ( [5] = '('
            call_expression [350] = 'doubled.begin()'
              function: field_expression [361] = 'doubled.begin'
                argument: identifier [1] = 'doubled'
                operator: . [155] = '.'
                field: field_identifier [538] = 'begin'
              arguments: argument_list [360] = '()'
                ( [5] = '('
                ) [8] = ')'
            , [7] = ','
            call_expression [350] = 'doubled.end()'
              function: field_expression [361] = 'doubled.end'
                argument: identifier [1] = 'doubled'
                operator: . [155] = '.'
                field: field_identifier [538] = 'end'
              arguments: argument_list [360] = '()'
                ( [5] = '('
                ) [8] = ')'
            , [7] = ','
            identifier [1] = 'generic_print'
            ) [8] = ')'
        ; [42] = ';'
      expression_statement [317] = 'std::cout << std::endl;'
        binary_expression [341] = 'std::cout << std::endl'
          left: qualified_identifier [485] = 'std::cout'
            scope: namespace_identifier [539] = 'std'
            :: [49] = '::'
            name: identifier [1] = 'cout'
          operator: << [40] = '<<'
          right: qualified_identifier [485] = 'std::endl'
            scope: namespace_identifier [539] = 'std'
            :: [49] = '::'
            name: identifier [1] = 'endl'
        ; [42] = ';'
      } [66] = '}'
  comment [177] = '/**'
  template_declaration [386] = 'template<typename T>'
    template [184] = 'template'
    parameters: template_parameter_list [388] = '<typename T>'
      < [39] = '<'
      type_parameter_declaration [389] = 'typename T'
        typename [183] = 'typename'
        type_identifier [542] = 'T'
      > [36] = '>'
    function_definition [254] = 'void perfect_forward(T&& value) {'
      type: primitive_type [96] = 'void'
      declarator: function_declarator [286] = 'perfect_forward(T&& value)'
        declarator: identifier [1] = 'perfect_forward'
        parameters: parameter_list [310] = '(T&& value)'
          ( [5] = '('
          parameter_declaration [311] = 'T&& value'
            type: type_identifier [542] = 'T'
            declarator: reference_declarator [412] = '&& value'
              && [30] = '&&'
              identifier [1] = 'value'
          ) [8] = ')'
      body: compound_statement [295] = '{'
        { [65] = '{'
        comment [177] = '// Demonstrate perfect forwarding'
        declaration [255] = 'auto process = [](auto&& arg) {'
          type: placeholder_type_specifier [374] = 'auto'
            auto [178] = 'auto'
          declarator: init_declarator [294] = 'process = [](auto&& arg) {'
            declarator: identifier [1] = 'process'
            = [74] = '='
            value: lambda_expression [464] = '[](auto&& arg) {'
              captures: lambda_capture_specifier [465] = '[]'
                [ [71] = '['
                ] [73] = ']'
              declarator: abstract_function_declarator [289] = '(auto&& arg)'
                parameters: parameter_list [310] = '(auto&& arg)'
                  ( [5] = '('
                  parameter_declaration [311] = 'auto&& arg'
                    type: placeholder_type_specifier [374] = 'auto'
                      auto [178] = 'auto'
                    declarator: reference_declarator [412] = '&& arg'
                      && [30] = '&&'
                      identifier [1] = 'arg'
                  ) [8] = ')'
              body: compound_statement [295] = '{'
                { [65] = '{'
                expression_statement [317]
                  binary_expression [341]
                    left: binary_expression [341]
                      left: binary_expression [341] = 'std::cout << "Processing: "'
                        left: qualified_identifier [485] = 'std::cout'
                          scope: namespace_identifier [539] = 'std'
                          :: [49] = '::'
                          name: identifier [1] = 'cout'
                        operator: << [40] = '<<'
                        right: string_literal [371] = '"Processing: "'
                          " [169] = '"'
                          string_content [170] = 'Processing: '
                          " [169] = '"'
                      operator: << [40] = '<<'
                      right: call_expression [350] = 'std::forward<decltype(arg)>(arg)'
                        function: qualified_identifier [485] = 'std::forward<decltype(arg)>'
                          scope: namespace_identifier [539] = 'std'
                          :: [49] = '::'
                          name: template_function [428] = 'forward<decltype(arg)>'
                            name: identifier [1] = 'forward'
                            arguments: template_argument_list [429] = '<decltype(arg)>'
                              < [39] = '<'
                              type_descriptor [344] = 'decltype(arg)'
                                type: decltype [376] = 'decltype(arg)'
                                  decltype [179] = 'decltype'
                                  ( [5] = '('
                                  identifier [1] = 'arg'
                                  ) [8] = ')'
                              > [36] = '>'
                        arguments: argument_list [360] = '(arg)'
                          ( [5] = '('
                          identifier [1] = 'arg'
                          ) [8] = ')'
                    operator: << [40] = '<<'
                    right: qualified_identifier [485] = 'std::endl'
                      scope: namespace_identifier [539] = 'std'
                      :: [49] = '::'
                      name: identifier [1] = 'endl'
                  ; [42] = ';'
                } [66] = '}'
          ; [42] = ';'
        expression_statement [317] = 'process(std::forward<T>(value));'
          call_expression [350] = 'process(std::forward<T>(value))'
            function: identifier [1] = 'process'
            arguments: argument_list [360] = '(std::forward<T>(value))'
              ( [5] = '('
              call_expression [350] = 'std::forward<T>(value)'
                function: qualified_identifier [485] = 'std::forward<T>'
                  scope: namespace_identifier [539] = 'std'
                  :: [49] = '::'
                  name: template_function [428] = 'forward<T>'
                    name: identifier [1] = 'forward'
                    arguments: template_argument_list [429] = '<T>'
                      < [39] = '<'
                      type_descriptor [344] = 'T'
                        type: type_identifier [542] = 'T'
                      > [36] = '>'
                arguments: argument_list [360] = '(value)'
                  ( [5] = '('
                  identifier [1] = 'value'
                  ) [8] = ')'
              ) [8] = ')'
          ; [42] = ';'
        } [66] = '}'
  comment [177] = '/**'
  function_definition [254] = 'int main() {'
    type: primitive_type [96] = 'int'
    declarator: function_declarator [286] = 'main()'
      declarator: identifier [1] = 'main'
      parameters: parameter_list [310] = '()'
        ( [5] = '('
        ) [8] = ')'
    body: compound_statement [295] = '{'
      { [65] = '{'
      expression_statement [317]
        binary_expression [341]
          left: binary_expression [341]
            left: qualified_identifier [485] = 'std::cout'
              scope: namespace_identifier [539] = 'std'
              :: [49] = '::'
              name: identifier [1] = 'cout'
            operator: << [40] = '<<'
            right: string_literal [371] = '"=== C++ Comprehensive Example ==="'
              " [169] = '"'
              string_content [170] = '=== C++ Comprehensive Example ==='
              " [169] = '"'
          operator: << [40] = '<<'
          right: qualified_identifier [485] = 'std::endl'
            scope: namespace_identifier [539] = 'std'
            :: [49] = '::'
            name: identifier [1] = 'endl'
        ; [42] = ';'
      comment [177] = '// Polymorphism demonstration'
      declaration [255]
        type: qualified_identifier [485]
          scope: namespace_identifier [539] = 'std'
          :: [49] = '::'
          name: template_type [426] = 'vector<std::unique_ptr<geometry::Shape>>'
            name: type_identifier [542] = 'vector'
            arguments: template_argument_list [429] = '<std::unique_ptr<geometry::Shape>>'
              < [39] = '<'
              type_descriptor [344] = 'std::unique_ptr<geometry::Shape>'
                type: qualified_identifier [485] = 'std::unique_ptr<geometry::Shape>'
                  scope: namespace_identifier [539] = 'std'
                  :: [49] = '::'
                  name: template_type [426] = 'unique_ptr<geometry::Shape>'
                    name: type_identifier [542] = 'unique_ptr'
                    arguments: template_argument_list [429] = '<geometry::Shape>'
                      < [39] = '<'
                      type_descriptor [344] = 'geometry::Shape'
                        type: qualified_identifier [485] = 'geometry::Shape'
                          scope: namespace_identifier [539] = 'geometry'
                          :: [49] = '::'
                          name: type_identifier [542] = 'Shape'
                      > [36] = '>'
              > [36] = '>'
        declarator: identifier [1] = 'shapes'
        ; [42] = ';'
      expression_statement [317]
        call_expression [350]
          function: field_expression [361] = 'shapes.push_back'
            argument: identifier [1] = 'shapes'
            operator: . [155] = '.'
            field: field_identifier [538] = 'push_back'
          arguments: argument_list [360]
            ( [5] = '('
            call_expression [350] = 'std::make_unique<geometry::Circle>(5.0)'
              function: qualified_identifier [485] = 'std::make_unique<geometry::Circle>'
                scope: namespace_identifier [539] = 'std'
                :: [49] = '::'
                name: template_function [428] = 'make_unique<geometry::Circle>'
                  name: identifier [1] = 'make_unique'
                  arguments: template_argument_list [429] = '<geometry::Circle>'
                    < [39] = '<'
                    type_descriptor [344] = 'geometry::Circle'
                      type: qualified_identifier [485] = 'geometry::Circle'
                        scope: namespace_identifier [539] = 'geometry'
                        :: [49] = '::'
                        name: type_identifier [542] = 'Circle'
                    > [36] = '>'
              arguments: argument_list [360] = '(5.0)'
                ( [5] = '('
                number_literal [158] = '5.0'
                ) [8] = ')'
            ) [8] = ')'
        ; [42] = ';'
      expression_statement [317]
        call_expression [350]
          function: field_expression [361] = 'shapes.push_back'
            argument: identifier [1] = 'shapes'
            operator: . [155] = '.'
            field: field_identifier [538] = 'push_back'
          arguments: argument_list [360]
            ( [5] = '('
            call_expression [350]
              function: qualified_identifier [485] = 'std::make_unique<geometry::Rectangle>'
                scope: namespace_identifier [539] = 'std'
                :: [49] = '::'
                name: template_function [428] = 'make_unique<geometry::Rectangle>'
                  name: identifier [1] = 'make_unique'
                  arguments: template_argument_list [429] = '<geometry::Rectangle>'
                    < [39] = '<'
                    type_descriptor [344] = 'geometry::Rectangle'
                      type: qualified_identifier [485] = 'geometry::Rectangle'
                        scope: namespace_identifier [539] = 'geometry'
                        :: [49] = '::'
                        name: type_identifier [542] = 'Rectangle'
                    > [36] = '>'
              arguments: argument_list [360] = '(4.0, 6.0)'
                ( [5] = '('
                number_literal [158] = '4.0'
                , [7] = ','
                number_literal [158] = '6.0'
                ) [8] = ')'
            ) [8] = ')'
        ; [42] = ';'
      for_range_loop [438] = 'for (const auto& shape : shapes) {'
        for [109] = 'for'
        ( [5] = '('
        type_qualifier [297] = 'const'
          const [82] = 'const'
        type: placeholder_type_specifier [374] = 'auto'
          auto [178] = 'auto'
        declarator: reference_declarator [412] = '& shape'
          & [33] = '&'
          identifier [1] = 'shape'
        : [101] = ':'
        right: identifier [1] = 'shapes'
        ) [8] = ')'
        body: compound_statement [295] = '{'
          { [65] = '{'
          expression_statement [317] = 'shape->display();'
            call_expression [350] = 'shape->display()'
              function: field_expression [361] = 'shape->display'
                argument: identifier [1] = 'shape'
                operator: -> [157] = '->'
                field: field_identifier [538] = 'display'
              arguments: argument_list [360] = '()'
                ( [5] = '('
                ) [8] = ')'
            ; [42] = ';'
          } [66] = '}'
      comment [177] = '// Template usage'
      expression_statement [317]
        binary_expression [341]
          left: binary_expression [341]
            left: binary_expression [341] = 'std::cout << "Max of 10 and 20: "'
              left: qualified_identifier [485] = 'std::cout'
                scope: namespace_identifier [539] = 'std'
                :: [49] = '::'
                name: identifier [1] = 'cout'
              operator: << [40] = '<<'
              right: string_literal [371] = '"Max of 10 and 20: "'
                " [169] = '"'
                string_content [170] = 'Max of 10 and 20: '
                " [169] = '"'
            operator: << [40] = '<<'
            right: call_expression [350] = 'utils::max(10, 20)'
              function: qualified_identifier [485] = 'utils::max'
                scope: namespace_identifier [539] = 'utils'
                :: [49] = '::'
                name: identifier [1] = 'max'
              arguments: argument_list [360] = '(10, 20)'
                ( [5] = '('
                number_literal [158] = '10'
                , [7] = ','
                number_literal [158] = '20'
                ) [8] = ')'
          operator: << [40] = '<<'
          right: qualified_identifier [485] = 'std::endl'
            scope: namespace_identifier [539] = 'std'
            :: [49] = '::'
            name: identifier [1] = 'endl'
        ; [42] = ';'
      expression_statement [317]
        binary_expression [341]
          left: binary_expression [341]
            left: binary_expression [341] = 'std::cout << "Max of 3.14 and 2.71: "'
              left: qualified_identifier [485] = 'std::cout'
                scope: namespace_identifier [539] = 'std'
                :: [49] = '::'
                name: identifier [1] = 'cout'
              operator: << [40] = '<<'
              right: string_literal [371] = '"Max of 3.14 and 2.71: "'
                " [169] = '"'
                string_content [170] = 'Max of 3.14 and 2.71: '
                " [169] = '"'
            operator: << [40] = '<<'
            right: call_expression [350] = 'utils::max(3.14, 2.71)'
              function: qualified_identifier [485] = 'utils::max'
                scope: namespace_identifier [539] = 'utils'
                :: [49] = '::'
                name: identifier [1] = 'max'
              arguments: argument_list [360] = '(3.14, 2.71)'
                ( [5] = '('
                number_literal [158] = '3.14'
                , [7] = ','
                number_literal [158] = '2.71'
                ) [8] = ')'
          operator: << [40] = '<<'
          right: qualified_identifier [485] = 'std::endl'
            scope: namespace_identifier [539] = 'std'
            :: [49] = '::'
            name: identifier [1] = 'endl'
        ; [42] = ';'
      comment [177] = '// Container filtering with templates'
      declaration [255]
        type: qualified_identifier [485] = 'std::vector<int>'
          scope: namespace_identifier [539] = 'std'
          :: [49] = '::'
          name: template_type [426] = 'vector<int>'
            name: type_identifier [542] = 'vector'
            arguments: template_argument_list [429] = '<int>'
              < [39] = '<'
              type_descriptor [344] = 'int'
                type: primitive_type [96] = 'int'
              > [36] = '>'
        declarator: init_declarator [294]
          declarator: identifier [1] = 'numbers'
          = [74] = '='
          value: initializer_list [364] = '{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}'
            { [65] = '{'
            number_literal [158] = '1'
            , [7] = ','
            number_literal [158] = '2'
            , [7] = ','
            number_literal [158] = '3'
            , [7] = ','
            number_literal [158] = '4'
            , [7] = ','
            number_literal [158] = '5'
            , [7] = ','
            number_literal [158] = '6'
            , [7] = ','
            number_literal [158] = '7'
            , [7] = ','
            number_literal [158] = '8'
            , [7] = ','
            number_literal [158] = '9'
            , [7] = ','
            number_literal [158] = '10'
            } [66] = '}'
        ; [42] = ';'
      declaration [255]
        type: placeholder_type_specifier [374] = 'auto'
          auto [178] = 'auto'
        declarator: init_declarator [294]
          declarator: identifier [1] = 'even_numbers'
          = [74] = '='
          value: call_expression [350]
            function: qualified_identifier [485] = 'utils::filter'
              scope: namespace_identifier [539] = 'utils'
              :: [49] = '::'
              name: identifier [1] = 'filter'
            arguments: argument_list [360]
              ( [5] = '('
              identifier [1] = 'numbers'
              , [7] = ','
              lambda_expression [464] = '[](int x) { return x % 2 == 0; }'
                captures: lambda_capture_specifier [465] = '[]'
                  [ [71] = '['
                  ] [73] = ']'
                declarator: abstract_function_declarator [289] = '(int x)'
                  parameters: parameter_list [310] = '(int x)'
                    ( [5] = '('
                    parameter_declaration [311] = 'int x'
                      type: primitive_type [96] = 'int'
                      declarator: identifier [1] = 'x'
                    ) [8] = ')'
                body: compound_statement [295] = '{ return x % 2 == 0; }'
                  { [65] = '{'
                  return_statement [326] = 'return x % 2 == 0;'
                    return [110] = 'return'
                    binary_expression [341] = 'x % 2 == 0'
                      left: binary_expression [341] = 'x % 2'
                        left: identifier [1] = 'x'
                        operator: % [28] = '%'
                        right: number_literal [158] = '2'
                      operator: == [34] = '=='
                      right: number_literal [158] = '0'
                    ; [42] = ';'
                  } [66] = '}'
              ) [8] = ')'
        ; [42] = ';'
      expression_statement [317] = 'std::cout << "Even numbers: ";'
        binary_expression [341] = 'std::cout << "Even numbers: "'
          left: qualified_identifier [485] = 'std::cout'
            scope: namespace_identifier [539] = 'std'
            :: [49] = '::'
            name: identifier [1] = 'cout'
          operator: << [40] = '<<'
          right: string_literal [371] = '"Even numbers: "'
            " [169] = '"'
            string_content [170] = 'Even numbers: '
            " [169] = '"'
        ; [42] = ';'
      for_range_loop [438] = 'for (int n : even_numbers) {'
        for [109] = 'for'
        ( [5] = '('
        type: primitive_type [96] = 'int'
        declarator: identifier [1] = 'n'
        : [101] = ':'
        right: identifier [1] = 'even_numbers'
        ) [8] = ')'
        body: compound_statement [295] = '{'
          { [65] = '{'
          expression_statement [317] = 'std::cout << n << " ";'
            binary_expression [341] = 'std::cout << n << " "'
              left: binary_expression [341] = 'std::cout << n'
                left: qualified_identifier [485] = 'std::cout'
                  scope: namespace_identifier [539] = 'std'
                  :: [49] = '::'
                  name: identifier [1] = 'cout'
                operator: << [40] = '<<'
                right: identifier [1] = 'n'
              operator: << [40] = '<<'
              right: string_literal [371] = '" "'
                " [169] = '"'
                string_content [170] = ' '
                " [169] = '"'
            ; [42] = ';'
          } [66] = '}'
      expression_statement [317] = 'std::cout << std::endl;'
        binary_expression [341] = 'std::cout << std::endl'
          left: qualified_identifier [485] = 'std::cout'
            scope: namespace_identifier [539] = 'std'
            :: [49] = '::'
            name: identifier [1] = 'cout'
          operator: << [40] = '<<'
          right: qualified_identifier [485] = 'std::endl'
            scope: namespace_identifier [539] = 'std'
            :: [49] = '::'
            name: identifier [1] = 'endl'
        ; [42] = ';'
      comment [177] = '// Exception handling demonstration'
      expression_statement [317] = 'demonstrate_exceptions(false);'
        call_expression [350] = 'demonstrate_exceptions(false)'
          function: identifier [1] = 'demonstrate_exceptions'
          arguments: argument_list [360] = '(false)'
            ( [5] = '('
            false [174] = 'false'
            ) [8] = ')'
        ; [42] = ';'
      comment [177] = '// Normal operation'
      expression_statement [317] = 'demonstrate_exceptions(true);'
        call_expression [350] = 'demonstrate_exceptions(true)'
          function: identifier [1] = 'demonstrate_exceptions'
          arguments: argument_list [360] = '(true)'
            ( [5] = '('
            true [173] = 'true'
            ) [8] = ')'
        ; [42] = ';'
      comment [177] = '// Trigger exception'
      comment [177] = '// Lambda demonstration'
      expression_statement [317] = 'demonstrate_lambdas();'
        call_expression [350] = 'demonstrate_lambdas()'
          function: identifier [1] = 'demonstrate_lambdas'
          arguments: argument_list [360] = '()'
            ( [5] = '('
            ) [8] = ')'
        ; [42] = ';'
      comment [177] = '// Perfect forwarding demonstration'
      declaration [255] = 'std::string text = "Hello, World!";'
        type: qualified_identifier [485] = 'std::string'
          scope: namespace_identifier [539] = 'std'
          :: [49] = '::'
          name: type_identifier [542] = 'string'
        declarator: init_declarator [294] = 'text = "Hello, World!"'
          declarator: identifier [1] = 'text'
          = [74] = '='
          value: string_literal [371] = '"Hello, World!"'
            " [169] = '"'
            string_content [170] = 'Hello, World!'
            " [169] = '"'
        ; [42] = ';'
      expression_statement [317] = 'perfect_forward(text);'
        call_expression [350] = 'perfect_forward(text)'
          function: identifier [1] = 'perfect_forward'
          arguments: argument_list [360] = '(text)'
            ( [5] = '('
            identifier [1] = 'text'
            ) [8] = ')'
        ; [42] = ';'
      comment [177] = '// lvalue'
      expression_statement [317] = 'perfect_forward(std::string("Temp"));'
        call_expression [350] = 'perfect_forward(std::string("Temp"))'
          function: identifier [1] = 'perfect_forward'
          arguments: argument_list [360] = '(std::string("Temp"))'
            ( [5] = '('
            call_expression [350] = 'std::string("Temp")'
              function: qualified_identifier [485] = 'std::string'
                scope: namespace_identifier [539] = 'std'
                :: [49] = '::'
                name: identifier [1] = 'string'
              arguments: argument_list [360] = '("Temp")'
                ( [5] = '('
                string_literal [371] = '"Temp"'
                  " [169] = '"'
                  string_content [170] = 'Temp'
                  " [169] = '"'
                ) [8] = ')'
            ) [8] = ')'
        ; [42] = ';'
      comment [177] = '// rvalue'
      comment [177] = '// Auto type deduction'
      declaration [255] = 'auto automatic_int = 42;'
        type: placeholder_type_specifier [374] = 'auto'
          auto [178] = 'auto'
        declarator: init_declarator [294] = 'automatic_int = 42'
          declarator: identifier [1] = 'automatic_int'
          = [74] = '='
          value: number_literal [158] = '42'
        ; [42] = ';'
      declaration [255] = 'auto automatic_double = 3.14159;'
        type: placeholder_type_specifier [374] = 'auto'
          auto [178] = 'auto'
        declarator: init_declarator [294] = 'automatic_double = 3.14159'
          declarator: identifier [1] = 'automatic_double'
          = [74] = '='
          value: number_literal [158] = '3.14159'
        ; [42] = ';'
      declaration [255]
        type: placeholder_type_specifier [374] = 'auto'
          auto [178] = 'auto'
        declarator: init_declarator [294]
          declarator: identifier [1] = 'automatic_string'
          = [74] = '='
          value: call_expression [350] = 'std::string("auto deduction")'
            function: qualified_identifier [485] = 'std::string'
              scope: namespace_identifier [539] = 'std'
              :: [49] = '::'
              name: identifier [1] = 'string'
            arguments: argument_list [360] = '("auto deduction")'
              ( [5] = '('
              string_literal [371] = '"auto deduction"'
                " [169] = '"'
                string_content [170] = 'auto deduction'
                " [169] = '"'
              ) [8] = ')'
        ; [42] = ';'
      expression_statement [317] = 'std::cout << "Auto deduced types: " '
        binary_expression [341] = 'std::cout << "Auto deduced types: " '
          left: binary_expression [341] = 'std::cout << "Auto deduced types: " '
            left: binary_expression [341] = 'std::cout << "Auto deduced types: " '
              left: binary_expression [341] = 'std::cout << "Auto deduced types: " '
                left: binary_expression [341] = 'std::cout << "Auto deduced types: " '
                  left: binary_expression [341] = 'std::cout << "Auto deduced types: " '
                    left: binary_expression [341] = 'std::cout << "Auto deduced types: "'
                      left: qualified_identifier [485] = 'std::cout'
                        scope: namespace_identifier [539] = 'std'
                        :: [49] = '::'
                        name: identifier [1] = 'cout'
                      operator: << [40] = '<<'
                      right: string_literal [371] = '"Auto deduced types: "'
                        " [169] = '"'
                        string_content [170] = 'Auto deduced types: '
                        " [169] = '"'
                    operator: << [40] = '<<'
                    right: identifier [1] = 'automatic_int'
                  operator: << [40] = '<<'
                  right: string_literal [371] = '", "'
                    " [169] = '"'
                    string_content [170] = ', '
                    " [169] = '"'
                operator: << [40] = '<<'
                right: identifier [1] = 'automatic_double'
              operator: << [40] = '<<'
              right: string_literal [371] = '", "'
                " [169] = '"'
                string_content [170] = ', '
                " [169] = '"'
            operator: << [40] = '<<'
            right: identifier [1] = 'automatic_string'
          operator: << [40] = '<<'
          right: qualified_identifier [485] = 'std::endl'
            scope: namespace_identifier [539] = 'std'
            :: [49] = '::'
            name: identifier [1] = 'endl'
        ; [42] = ';'
      comment [177] = '// Range-based for loops'
      expression_statement [317] = 'std::cout << "Numbers: ";'
        binary_expression [341] = 'std::cout << "Numbers: "'
          left: qualified_identifier [485] = 'std::cout'
            scope: namespace_identifier [539] = 'std'
            :: [49] = '::'
            name: identifier [1] = 'cout'
          operator: << [40] = '<<'
          right: string_literal [371] = '"Numbers: "'
            " [169] = '"'
            string_content [170] = 'Numbers: '
            " [169] = '"'
        ; [42] = ';'
      for_range_loop [438] = 'for (const auto& num : numbers) {'
        for [109] = 'for'
        ( [5] = '('
        type_qualifier [297] = 'const'
          const [82] = 'const'
        type: placeholder_type_specifier [374] = 'auto'
          auto [178] = 'auto'
        declarator: reference_declarator [412] = '& num'
          & [33] = '&'
          identifier [1] = 'num'
        : [101] = ':'
        right: identifier [1] = 'numbers'
        ) [8] = ')'
        body: compound_statement [295] = '{'
          { [65] = '{'
          expression_statement [317] = 'std::cout << num << " ";'
            binary_expression [341] = 'std::cout << num << " "'
              left: binary_expression [341] = 'std::cout << num'
                left: qualified_identifier [485] = 'std::cout'
                  scope: namespace_identifier [539] = 'std'
                  :: [49] = '::'
                  name: identifier [1] = 'cout'
                operator: << [40] = '<<'
                right: identifier [1] = 'num'
              operator: << [40] = '<<'
              right: string_literal [371] = '" "'
                " [169] = '"'
                string_content [170] = ' '
                " [169] = '"'
            ; [42] = ';'
          } [66] = '}'
      expression_statement [317] = 'std::cout << std::endl;'
        binary_expression [341] = 'std::cout << std::endl'
          left: qualified_identifier [485] = 'std::cout'
            scope: namespace_identifier [539] = 'std'
            :: [49] = '::'
            name: identifier [1] = 'cout'
          operator: << [40] = '<<'
          right: qualified_identifier [485] = 'std::endl'
            scope: namespace_identifier [539] = 'std'
            :: [49] = '::'
            name: identifier [1] = 'endl'
        ; [42] = ';'
      return_statement [326] = 'return 0;'
        return [110] = 'return'
        number_literal [158] = '0'
        ; [42] = ';'
      } [66] = '}'
```

## Node Type Statistics

| Node Type | Count | Max Depth |
|-----------|-------|----------|
| != | 1 | 8 |
| " | 50 | 13 |
| #include | 7 | 2 |
| % | 1 | 12 |
| & | 19 | 10 |
| && | 4 | 11 |
| ( | 98 | 17 |
| ) | 98 | 17 |
| * | 10 | 12 |
| + | 1 | 11 |
| ++ | 1 | 7 |
| += | 1 | 9 |
| , | 41 | 9 |
| -> | 2 | 8 |
| . | 20 | 12 |
| : | 22 | 8 |
| :: | 68 | 14 |
| ; | 90 | 10 |
| < | 20 | 15 |
| << | 48 | 12 |
| = | 25 | 9 |
| == | 1 | 11 |
| > | 22 | 15 |
| ? | 2 | 8 |
| [ | 10 | 13 |
| [] | 2 | 7 |
| ] | 10 | 13 |
| abstract_array_declarator | 2 | 12 |
| abstract_function_declarator | 5 | 8 |
| abstract_reference_declarator | 2 | 8 |
| access_specifier | 12 | 5 |
| argument_list | 51 | 12 |
| assignment_expression | 6 | 8 |
| auto | 13 | 11 |
| base_class_clause | 3 | 4 |
| binary_expression | 64 | 11 |
| call_expression | 42 | 11 |
| catch | 2 | 5 |
| catch_clause | 2 | 4 |
| class | 7 | 6 |
| class_specifier | 5 | 3 |
| comment | 53 | 5 |
| compound_statement | 40 | 8 |
| condition_clause | 3 | 6 |
| conditional_expression | 2 | 7 |
| const | 26 | 10 |
| constexpr | 2 | 6 |
| declaration | 18 | 6 |
| declaration_list | 2 | 2 |
| decltype | 2 | 17 |
| default | 1 | 7 |
| default_method_clause | 1 | 6 |
| delete | 2 | 5 |
| delete_method_clause | 2 | 4 |
| dependent_type | 2 | 12 |
| destructor_name | 2 | 7 |
| escape_sequence | 2 | 10 |
| explicit | 3 | 7 |
| explicit_function_specifier | 3 | 6 |
| expression_statement | 39 | 8 |
| false | 1 | 6 |
| field_declaration | 6 | 5 |
| field_declaration_list | 5 | 4 |
| field_expression | 21 | 11 |
| field_identifier | 45 | 12 |
| field_initializer | 8 | 7 |
| field_initializer_list | 5 | 6 |
| for | 4 | 6 |
| for_range_loop | 3 | 3 |
| for_statement | 1 | 5 |
| function_declarator | 29 | 6 |
| function_definition | 28 | 5 |
| identifier | 209 | 17 |
| if | 3 | 6 |
| if_statement | 3 | 5 |
| init_declarator | 15 | 7 |
| initializer_list | 2 | 5 |
| lambda_capture_specifier | 5 | 8 |
| lambda_expression | 5 | 7 |
| namespace | 2 | 2 |
| namespace_definition | 2 | 1 |
| namespace_identifier | 70 | 14 |
| noexcept | 10 | 8 |
| number_literal | 45 | 12 |
| operator | 4 | 7 |
| operator_name | 4 | 6 |
| override | 5 | 8 |
| parameter_declaration | 26 | 10 |
| parameter_list | 36 | 9 |
| parenthesized_expression | 3 | 9 |
| placeholder_type_specifier | 13 | 10 |
| pointer_declarator | 1 | 4 |
| pointer_expression | 2 | 8 |
| preproc_include | 7 | 1 |
| primitive_type | 43 | 13 |
| private | 4 | 6 |
| public | 8 | 6 |
| qualified_identifier | 68 | 13 |
| reference_declarator | 19 | 10 |
| return | 17 | 10 |
| return_statement | 17 | 9 |
| string_content | 25 | 13 |
| string_literal | 25 | 12 |
| subscript_argument_list | 3 | 10 |
| subscript_expression | 3 | 9 |
| system_lib_string | 7 | 2 |
| template | 4 | 4 |
| template_argument_list | 15 | 14 |
| template_declaration | 4 | 3 |
| template_function | 7 | 13 |
| template_parameter_list | 4 | 4 |
| template_type | 8 | 9 |
| this | 2 | 8 |
| throw | 1 | 8 |
| throw_statement | 1 | 7 |
| trailing_return_type | 1 | 6 |
| translation_unit | 1 | 0 |
| true | 1 | 6 |
| try | 1 | 4 |
| try_statement | 1 | 3 |
| type_descriptor | 16 | 15 |
| type_identifier | 44 | 14 |
| type_parameter_declaration | 4 | 5 |
| type_qualifier | 28 | 9 |
| typename | 4 | 13 |
| update_expression | 1 | 6 |
| virtual | 3 | 6 |
| virtual_specifier | 5 | 7 |
| { | 49 | 9 |
| } | 49 | 9 |
| ~ | 2 | 8 |

**Total unique node types**: 131
